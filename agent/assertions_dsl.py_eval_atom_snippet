    def _eval_atom(self, assertion: str) -> bool:
        """Evaluate atomic assertion"""
        print(f"DEBUG: Eval Atom: '{assertion}'")

        # exists("<selector>")
        match = re.match(r'exists\("(.+?)"\)', assertion)
        if match:
            selector = match.group(1)
            return self.page.locator(selector).count() > 0

        # text("<selector>") == "<str>" or text("<selector>") != ""
        match = re.match(r'text([\'\'](.+?)[\'\'])\s*(==|!=|includes)\s*[\'\'](.*?)[\'\']', assertion)
        if match:
            selector, op, expected = match.groups()
            try:
                actual = self.page.locator(selector).inner_text()
                if op == '==':
                    return actual == expected
                elif op == '!=':
                    return actual != expected
                elif op == 'includes':
                    return expected in actual
            except:
                return False

        # text("<selector>") == mem("<key>")
        match = re.match(r'text\("(.+?)"\)\s*==\s*mem\(\'(.+?)\'\)', assertion)
        if match:
            selector, mem_key = match.groups()
            try:
                actual = self.page.locator(selector).inner_text()
                expected = self._get_memory(mem_key)
                return str(actual) == str(expected)
            except:
                return False

        # attr("<selector>", "<name>") == "<value>"
        match = re.match(r'attr\("(.+?)",\s*"(.+?)"\)\s*(==|!=)\s*"(.+?)"', assertion)
        if match:
            selector, attr_name, op, expected = match.groups()
            try:
                actual = self.page.locator(selector).get_attribute(attr_name)
                if op == '==':
                    return actual == expected
                elif op == '!=':
                    return actual != expected
            except:
                return False

        # count("<selector>") >= N
        match = re.match(r'count\([\'\'](.+?)[\'\']\)\s*(>=|<=|==|>|<)\s*(\d+)', assertion)
        if match:
            selector, op, threshold = match.groups()
            threshold = int(threshold)
            actual_count = self.page.locator(selector).count()

            if op == '>=':
                return actual_count >= threshold
            elif op == '<=':
                return actual_count <= threshold
            elif op == '==':
                return actual_count == threshold
            elif op == '>':
                return actual_count > threshold
            elif op == '<':
                return actual_count < threshold

        # url().includes("<path>")
        match = re.match(r"url\(\)\.includes\(['"](.+?)['"]\)", assertion)
        if match:
            path = match.group(1)
            return path in self.page.url

        # mem("<key>") == "<expected>"
        match = re.match(r'mem\([\'\'](.+?)[\'\']\)\s*(==|!=|>=|<=|>|<|includes)\s*[\'\']?(.+?)[\'\']?$', assertion)
        if match:
            key, op, expected = match.groups()
            actual = self._get_memory(key)
            print(f"DEBUG: DSL mem check: key='{key}', op='{op}', expected='{expected}', actual='{actual}' (type: {type(actual)})")
            
            # Convert expected string to boolean if applicable
            if isinstance(actual, bool) and isinstance(expected, str):
                if expected.lower() == 'true': expected = True
                elif expected.lower() == 'false': expected = False
            
            if op == '==':
                # Try loose equality for numbers
                try:
                    if float(actual) == float(expected):
                        return True
                except (ValueError, TypeError):
                    pass
                return str(actual) == str(expected)
            elif op == '!=':
                return str(actual) != expected
            elif op == 'includes':
                return expected in str(actual)
            elif op == '>=':
                return float(actual) >= float(expected)
            elif op == '<=':
                return float(actual) <= float(expected)
            elif op == '>':
                return float(actual) > float(expected)
            elif op == '<':
                return float(actual) < float(expected)

        # mem("<key>") != ""
        match = re.match(r'mem\([\'\'](.+?)[\'\']\)\s*!= \s*[\'\'][\'\']', assertion)
        if match:
            key = match.group(1)
            actual = self._get_memory(key)
            return actual is not None and str(actual) != ""

        # mem("<key>").includes("<value>")
        match = re.match(r'mem\([\'\'](.+?)[\'\']\)\.includes\([\'\'](.+?)[\'\']\)', assertion)
        if match:
            key, expected = match.groups()
            actual = self._get_memory(key)
            print(f"DEBUG: AssertionDSL mem includes check: key='{key}', expected='{expected}', actual='{actual}'")
            return expected in str(actual)

        # json("<channel>", "<path>") == <value>
        match = re.match(r'json\([\'\'](.+?)[\'\']\s*,\s*[\'\'](.+?)[\'\']\)\s*(==|!=|>=|<=|>|<)\s*[\'\']?(.+?)[\'\']?$', assertion)
        if match:
            channel, path, op, expected = match.groups()
            try:
                actual = self.env_api_fn(channel, path)
                print(f"DEBUG: AssertionDSL json check: channel='{channel}', path='{path}', op='{op}', expected='{expected}', actual='{actual}'")
                # Try to parse expected as JSON
                try:
                    expected_val = json.loads(expected.replace("'", '"'))
                except:
                    expected_val = expected

                if op == '==':
                    return actual == expected_val
                elif op == '!=':
                    return actual != expected_val
                elif op in ('>=','<=','>','<'):
                    try:
                        a_val = float(actual)
                        b_val = float(expected_val)
                    except (TypeError, ValueError):
                        a_val = str(actual)
                        b_val = str(expected_val)
                    if op == '>=':
                        return a_val >= b_val
                    if op == '<=':
                        return a_val <= b_val
                    if op == '>':
                        return a_val > b_val
                    if op == '<':
                        return a_val < b_val
            except:
                return False

        raise ValueError(f"Unknown assertion format: {assertion}")

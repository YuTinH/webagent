"""
Task Executor - Execute web agent tasks using Playwright

This module provides the core execution engine for running tasks defined
in task_spec.json files. It uses Playwright to control the browser and
execute the steps defined in oracle traces or generated by an agent.
"""

import json
import time
import os
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from playwright.sync_api import sync_playwright, Page, Browser, BrowserContext

# Import our custom modules
from .assertions_dsl import AssertionDSL
from .error_handlers import (
    TimeoutHandler, NetworkErrorHandler, ElementNotFoundHandler,
    AssertionFailureHandler, check_preconditions, ErrorReport
)


class ExecutionResult:
    """Result of a task execution"""

    def __init__(self, task_id: str):
        self.task_id = task_id
        self.success = False
        self.final_state = "pending"  # pending, running, completed, failed, aborted
        self.steps_completed = 0
        self.steps_total = 0
        self.time_elapsed = 0.0
        self.error = None
        self.trace = []
        self.memory_updates = {}
        self.artifacts = []
        self.warnings = []
        self.extracted_data = {}

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "task_id": self.task_id,
            "success": self.success,
            "final_state": self.final_state,
            "steps_completed": self.steps_completed,
            "steps_total": self.steps_total,
            "time_elapsed": self.time_elapsed,
            "error": self.error.to_dict() if self.error else None,
            "trace": self.trace,
            "memory_updates": self.memory_updates,
            "artifacts": self.artifacts,
            "warnings": self.warnings,
            "extracted_data": self.extracted_data
        }


class TaskExecutor:
    """Main task executor using Playwright"""

    SUITE_PORT = int(os.getenv("WEB_SUITE_PORT", "8014"))

    def __init__(
        self,
        database_path: str = "data.db",
        env_api_url: Optional[str] = None,
        headless: bool = False,
        slow_mo: int = 0
    ):
        """
        Initialize task executor

        Args:
            database_path: Path to SQLite database
            env_api_url: URL for environment API
            headless: Run browser in headless mode
            slow_mo: Slow down operations by N milliseconds
        """
        self.database_path = database_path
        self.env_api_url = env_api_url or f"http://localhost:{self.SUITE_PORT}/api/env"
        self.headless = headless
        self.slow_mo = slow_mo

        # State
        self.memory = {}  # In-memory KV store
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None

        # Load memory from database
        self._load_memory()

    def _load_memory(self):
        """Load memory from database"""
        if not os.path.exists(self.database_path):
            print(f"âš ï¸  Database not found: {self.database_path}")
            return

        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()
            cursor.execute("SELECT key, value FROM memory_kv")

            for row in cursor.fetchall():
                key, value = row
                if 'courses.DL101.state' in key:
                    print(f"DEBUG: Loaded key {key} = {value}")
                try:
                    self.memory[key] = json.loads(value)
                except:
                    self.memory[key] = value

            conn.close()
            print(f"âœ… Loaded {len(self.memory)} memory entries from database")
        except Exception as e:
            print(f"âš ï¸  Error loading memory: {e}")

    def _save_memory(self, key: str, value: Any, source: str, confidence: float = 1.0):
        """Save memory entry to database"""
        if not os.path.exists(self.database_path):
            return

        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()

            # Serialize value to JSON
            value_json = json.dumps(value) if not isinstance(value, str) else value

            cursor.execute("""
                INSERT OR REPLACE INTO memory_kv (key, value, ts, source, confidence)
                VALUES (?, ?, ?, ?, ?)
            """, (key, value_json, datetime.utcnow().isoformat() + "Z", source, confidence))

            conn.commit()
            conn.close()

            # Update in-memory copy
            self.memory[key] = value

        except Exception as e:
            print(f"âš ï¸  Error saving memory: {e}")

    def _env_api(self, channel: str, path: str) -> Any:
        """Query environment API"""
        # TODO: Implement HTTP call to env API
        # For now, query database directly

        # Check JSON state first for new domains
        json_domains = ("health", "trips", "work", "expenses", "meters", "permits", "security", "payments", "contracts", "warranty", "courses", "invoices", "settlements", "autopay", "accounts", "finance", "food")
        parts = path.split('.')
        
        if parts[0] in json_domains:
            from pathlib import Path
            print(f"DEBUG: TaskExecutor._env_api reading from: {Path(__file__).parent.parent / 'env' / 'state.json'}")
            state_path = Path(__file__).parent.parent / 'env' / 'state.json' # Explicitly target webagent_dynamic_suite_v2_skin/env/state.json
            
            if state_path.exists():
                try:
                    current = json.loads(state_path.read_text(encoding='utf-8'))
                    for part in parts:
                        if isinstance(current, dict):
                            current = current.get(part)
                        elif isinstance(current, list):
                            try:
                                current = current[int(part)]
                            except (ValueError, IndexError):
                                return None
                        else:
                            return None
                        
                        if current is None:
                            print(f"DEBUG: _env_api traversal failed at part '{part}' for path '{path}'")
                            return None
                    print(f"DEBUG: _env_api found value: {current}")
                    return current
                except Exception:
                    pass

        if not os.path.exists(self.database_path):
            return None

        try:
            conn = sqlite3.connect(self.database_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()

            # Simple implementation: parse path like "orders.O-10001.state"
            # parts already split above

            if parts[0] == 'orders' and len(parts) >= 2:
                order_id = parts[1]
                if order_id == '*':
                    # Get most recent order
                    cursor.execute("SELECT * FROM orders ORDER BY created_at DESC LIMIT 1")
                else:
                    cursor.execute("SELECT * FROM orders WHERE id = ?", (order_id,))

                row = cursor.fetchone()
                if row and len(parts) >= 3:
                    field = parts[2]
                    result = row[field] if field in row.keys() else None
                    conn.close()
                    return result
                if row and len(parts) == 2 and parts[1] == '*':
                    conn.close()
                    return row['state']

            elif parts[0] == 'payments' and 'cards' in parts:
                # payments.cards.1234.state
                if len(parts) >= 4:
                    last4 = parts[2]
                    field = parts[3]
                    cursor.execute(f"SELECT {field} FROM cards WHERE last4 = ?", (last4,))
                    row = cursor.fetchone()
                    if row:
                        result = row[0]
                        conn.close()
                        return result

            elif parts[0] == 'accounts':
                # accounts.*.balance
                cursor.execute("SELECT * FROM accounts ORDER BY created_at DESC LIMIT 1")
                row = cursor.fetchone()
                if row and ('balance' in parts or parts[1] == '*'):
                    result = row['balance']
                    conn.close()
                    return result

            elif parts[0] == 'autopay':
                from pathlib import Path
                state_path = Path('env/state.json')
                if state_path.exists():
                    env_state = json.loads(state_path.read_text())
                    entries = env_state.get('autopay', {})
                    first = next(iter(entries.values()), None)
                    if first:
                        if len(parts) == 2 and parts[1] == '*':
                            conn.close()
                            return first
                        if len(parts) >= 3 and parts[1] == '*':
                            field = parts[2]
                            conn.close()
                            return first.get(field)

            conn.close()
            return None

        except Exception as e:
            print(f"âš ï¸  Error querying env API: {e}")
            return None

    def run(self, task_spec_path: str, oracle_trace_path: Optional[str] = None) -> ExecutionResult:
        """
        Execute a task

        Args:
            task_spec_path: Path to task_spec.json
            oracle_trace_path: Optional path to oracle_trace.json (for testing)

        Returns:
            ExecutionResult with execution details
        """
        print(f"DEBUG: Loading task spec from: {task_spec_path}")
        # Load task spec
        with open(task_spec_path) as f:
            task_spec = json.load(f)

        task_id = task_spec['task_id']
        print(f"\n{'='*80}")
        print(f"ðŸš€ Executing task: {task_id}")
        print(f"{'='*80}")

        result = ExecutionResult(task_id)
        start_time = time.time()

        try:
            # Check preconditions
            print("\nðŸ“‹ Checking preconditions...")
            print(f"DEBUG: Loaded preconditions: {task_spec.get('preconditions', [])}")
            self._check_preconditions(task_spec)
            print("âœ… All preconditions met")

            # Initialize extraction storage
            self._extracted_data = {}

            # Load oracle trace if provided
            steps = None
            if oracle_trace_path:
                with open(oracle_trace_path) as f:
                    oracle_trace = json.load(f)
                    steps = oracle_trace.get('steps', [])
                    result.steps_total = len(steps)
                    print(f"ðŸ“œ Loaded oracle trace with {len(steps)} steps")

            # Start browser
            print("\nðŸŒ Starting browser...")
            self._start_browser(task_spec)

            result.final_state = "running"

            # Execute steps
            if steps:
                print(f"\nâš¡ Executing {len(steps)} steps...")
                for i, step in enumerate(steps):
                    print(f"\n  Step {i+1}/{len(steps)}: {step.get('act')} {step.get('note', '')}")

                    try:
                        self._execute_step(step, task_spec)
                        result.steps_completed = i + 1
                        result.trace.append(step)

                    except Exception as e:
                        print(f"    âŒ Step failed: {e}")
                        result.error = self._handle_step_error(e, step, task_spec, i)

                        if result.error and result.error.final_state == "aborted":
                            break

            # Verify success criteria
            print("\nâœ“ Verifying success criteria...")
            success = self._verify_success(task_spec)

            if success:
                print("âœ… Task completed successfully!")
                result.success = True
                result.final_state = "completed"

                # Update memory
                self._update_memory(task_spec)
            else:
                print("âŒ Task failed: success criteria not met")
                result.final_state = "failed"
            
            # Populate extracted data in result
            if hasattr(self, '_extracted_data'):
                result.extracted_data = self._extracted_data

        except Exception as e:
            print(f"\nâŒ Task execution failed: {e}")
            result.final_state = "failed"
            result.error = ErrorReport(
                task_id=task_id,
                error_type="unknown",
                timestamp=datetime.utcnow().isoformat() + "Z",
                step_index=-1,
                error_message=str(e)
            )

        finally:
            # Cleanup
            result.time_elapsed = time.time() - start_time
            self._stop_browser()

        # Save result
        self._save_result(result)

        print(f"\n{'='*80}")
        print(f"ðŸ“Š Execution completed in {result.time_elapsed:.2f}s")
        print(f"   Success: {result.success}")
        print(f"   Steps: {result.steps_completed}/{result.steps_total}")
        print(f"{'='*80}\n")

        return result

    def _check_preconditions(self, task_spec: Dict[str, Any]):
        """Check task preconditions"""
        preconditions = task_spec.get('preconditions', [])
        print(f"DEBUG: TaskExecutor memory in preconditions check: health.insurance.active = {self.memory.get('health.insurance.active')}")

        if not preconditions:
            return

        # Create DSL evaluator
        dsl = AssertionDSL(None, self.memory, self._env_api)

        for precondition in preconditions:
            if "banking.balance" in precondition:
                 try:
                     val = self.memory.get("banking", {}).get("balance", {}).get("checking", "MISSING")
                 except:
                     val = "ERROR"
                 print(f"DEBUG: Checking {precondition}. Memory value: {val}")
            try:
                # For memory-only preconditions, we can evaluate without a page
                result = dsl.evaluate(precondition)
                if not result:
                    raise Exception(f"Precondition not met: {precondition}")
            except Exception as e:
                raise Exception(f"Precondition check failed: {precondition} - {e}")

    def _start_browser(self, task_spec: Dict[str, Any]):
        """Start Playwright browser"""
        self.playwright = sync_playwright().start()
        self.browser = self.playwright.chromium.launch(
            headless=self.headless,
            slow_mo=self.slow_mo,
            args=['--no-proxy-server']
        )

        self.context = self.browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )

        self.page = self.context.new_page()
        self.page.on("console", lambda msg: print(f"PAGE CONSOLE: {msg.text}"))

        # Set default timeout
        timeout = task_spec.get('step_timeout', 30) * 1000  # Convert to milliseconds
        self.page.set_default_timeout(timeout)

    def _stop_browser(self):
        """Stop browser"""
        if self.page:
            self.page.close()
        if self.context:
            self.context.close()
        if self.browser:
            self.browser.close()
        if hasattr(self, 'playwright'):
            self.playwright.stop()

    def _map_url(self, url: str) -> str:
        """Map domain URLs to localhost for testing"""
        import re
        # Map shop.local, bank.local, etc. to localhost:8000
        url = re.sub(
            r'https?://([\w.-]+\.local)',
            f"http://localhost:{self.SUITE_PORT}/" + r"\1",
            url,
        )
        return url

    def _execute_step(self, step: Dict[str, Any], task_spec: Dict[str, Any]):
        """Execute a single step"""
        action = step['act']

        if action == 'open':
            url = step['url']
            # Map domain URLs to localhost
            url = self._map_url(url)
            print(f"    â†’ Opening {url}")
            self.page.goto(url, wait_until='domcontentloaded')

        elif action == 'click':
            selector = step['selector']
            force = step.get('force', False)
            print(f"    â†’ Clicking {selector} (force={force})")
            self.page.click(selector, force=force)

        elif action == 'type':
            selector = step['selector']
            value = step['value']
            print(f"    â†’ Typing '{value}' into {selector}")
            self.page.fill(selector, value)

        elif action == 'select':
            selector = step['selector']
            value = step['value']
            print(f"    â†’ Selecting '{value}' from {selector}")
            self.page.select_option(selector, value)

        elif action == 'wait':
            selector = step['selector']
            print(f"    â†’ Waiting for {selector}")
            # Wait a bit for async operations
            import time
            time.sleep(1)
            self.page.wait_for_selector(selector)

        elif action == 'assert':
            selector = step.get('selector')
            expected = step.get('value')
            print(f"    â†’ Asserting {selector} == {expected}")

            # Get actual value
            if selector:
                actual = self.page.locator(selector).inner_text()

                # If no expected provided, assert element exists
                if expected is None:
                    if self.page.locator(selector).count() == 0:
                        raise AssertionError(f"{selector} not found")
                    return

                # Memory comparison mem('key')
                if isinstance(expected, str) and expected.startswith("mem('"):
                    key = expected.split("mem('",1)[1].split("')",1)[0]
                    expected_val = self.memory.get(key)
                    if str(actual).strip() != str(expected_val).strip():
                        raise AssertionError(f"Expected mem('{key}')='{expected_val}', got '{actual}'")
                    return

                # Numeric comparison like "<=30"
                if isinstance(expected, str) and str(expected).strip().startswith(('<=','>=')):
                    exp = str(expected).strip()
                    op, limit_str = exp[:2], exp[2:].strip()
                    limit = float(limit_str)
                    num_str = ''.join(ch for ch in actual if ch.isdigit() or ch == '.' or ch == '-')
                    actual_num = float(num_str) if num_str else 0.0
                    if op == '<=' and actual_num > limit:
                        raise AssertionError(f"Expected <= {limit}, got {actual_num}")
                    if op == '>=' and actual_num < limit:
                        raise AssertionError(f"Expected >= {limit}, got {actual_num}")
                else:
                    if str(actual).strip() != str(expected).strip():
                        raise AssertionError(f"Expected '{expected}', got '{actual}'")

        elif action == 'screenshot':
            screenshot_id = step.get('screenshot_id', 'screenshot')
            path = f"screenshots/{screenshot_id}.png"
            os.makedirs('screenshots', exist_ok=True)
            self.page.screenshot(path=path)
            print(f"    â†’ Screenshot saved to {path}")

        elif action == 'verify_state':
            """Verify system state (URL, memory, DOM) instead of taking screenshot"""
            checks = step.get('checks', [])
            print(f"    â†’ Verifying {len(checks)} state conditions")

            for check in checks:
                check_type = check.get('type')

                if check_type == 'url':
                    # Verify URL contains or matches pattern
                    if 'contains' in check:
                        expected = check['contains']
                        actual_url = self.page.url
                        if expected not in actual_url:
                            raise AssertionError(f"URL does not contain '{expected}'. Actual: {actual_url}")
                        print(f"      âœ“ URL contains '{expected}'")

                    elif 'pattern' in check:
                        import re
                        pattern = check['pattern']
                        actual_url = self.page.url
                        if not re.search(pattern, actual_url):
                            raise AssertionError(f"URL does not match pattern '{pattern}'. Actual: {actual_url}")
                        print(f"      âœ“ URL matches pattern '{pattern}'")

                    elif 'path' in check:
                        expected_path = check['path']
                        actual_url = self.page.url
                        if expected_path not in actual_url:
                            raise AssertionError(f"URL path does not contain '{expected_path}'. Actual: {actual_url}")
                        print(f"      âœ“ URL path contains '{expected_path}'")

                elif check_type == 'memory':
                    # Verify memory key exists or has specific value
                    key = check.get('key')

                    if 'exists' in check:
                        should_exist = check['exists']
                        exists = key in self.memory
                        if should_exist and not exists:
                            raise AssertionError(f"Memory key '{key}' does not exist")
                        if not should_exist and exists:
                            raise AssertionError(f"Memory key '{key}' should not exist")
                        print(f"      âœ“ Memory key '{key}' existence: {should_exist}")

                    elif 'value' in check:
                        expected = check['value']
                        actual = self.memory.get(key)
                        if str(actual) != str(expected):
                            raise AssertionError(f"Memory['{key}'] = '{actual}', expected '{expected}'")
                        print(f"      âœ“ Memory['{key}'] = '{expected}'")

                    elif 'not_empty' in check:
                        actual = self.memory.get(key)
                        if not actual or actual == '':
                            raise AssertionError(f"Memory key '{key}' is empty")
                        print(f"      âœ“ Memory['{key}'] is not empty")

                elif check_type == 'dom':
                    # Verify DOM element exists or has specific state
                    selector = check.get('selector')

                    if 'exists' in check:
                        should_exist = check['exists']
                        count = self.page.locator(selector).count()
                        exists = count > 0
                        if should_exist and not exists:
                            raise AssertionError(f"Element '{selector}' not found")
                        if not should_exist and exists:
                            raise AssertionError(f"Element '{selector}' should not exist")
                        print(f"      âœ“ Element '{selector}' existence: {should_exist}")

                    elif 'count' in check:
                        expected_count = check['count']
                        actual_count = self.page.locator(selector).count()
                        if actual_count != expected_count:
                            raise AssertionError(f"Element '{selector}' count: {actual_count}, expected {expected_count}")
                        print(f"      âœ“ Element '{selector}' count: {expected_count}")

                    elif 'text_contains' in check:
                        expected_text = check['text_contains']
                        actual_text = self.page.locator(selector).inner_text()
                        if expected_text not in actual_text:
                            raise AssertionError(f"Element '{selector}' text does not contain '{expected_text}'")
                        print(f"      âœ“ Element '{selector}' contains text '{expected_text}'")

                    elif 'not_empty' in check:
                        # Check if element has non-empty text content
                        text = self.page.locator(selector).inner_text().strip()
                        if not text:
                            raise AssertionError(f"Element '{selector}' is empty")
                        print(f"      âœ“ Element '{selector}' has content: '{text[:50]}...'")


            # Optional: take screenshot as backup if specified
            if step.get('screenshot_fallback'):
                screenshot_id = step.get('screenshot_id', 'verify_state')
                path = f"screenshots/{screenshot_id}.png"
                os.makedirs('screenshots', exist_ok=True)
                self.page.screenshot(path=path)
                print(f"      ðŸ“¸ Backup screenshot: {path}")

        elif action == 'verify_dom':
            """Verify multiple DOM selectors exist"""
            selectors = step.get('selectors', [])
            print(f"    â†’ Verifying {len(selectors)} DOM elements")

            for selector in selectors:
                count = self.page.locator(selector).count()
                if count == 0:
                    raise AssertionError(f"Element '{selector}' not found")
                print(f"      âœ“ Element '{selector}' exists")

        elif action == 'verify_memory':
            """Verify memory state"""
            key = step.get('key')

            if 'exists' in step:
                should_exist = step['exists']
                exists = key in self.memory
                if should_exist and not exists:
                    raise AssertionError(f"Memory key '{key}' does not exist")
                if not should_exist and exists:
                    raise AssertionError(f"Memory key '{key}' should not exist")
                print(f"    â†’ Memory key '{key}' existence verified: {should_exist}")

            elif 'value' in step:
                expected = step['value']
                actual = self.memory.get(key)
                if str(actual) != str(expected):
                    raise AssertionError(f"Memory['{key}'] = '{actual}', expected '{expected}'")
                print(f"    â†’ Memory['{key}'] = '{expected}' âœ“")

        elif action == 'upload':
            selector = step['selector']
            filepath = step['value']
            print(f"    â†’ Uploading {filepath} to {selector}")
            self.page.set_input_files(selector, filepath)

        elif action == 'download':
            # Start waiting for download
            with self.page.expect_download() as download_info:
                self.page.click(step['selector'])
            download = download_info.value

            # Save to downloads directory
            filename = step.get('value', download.suggested_filename)
            os.makedirs('downloads', exist_ok=True)
            download.save_as(f"downloads/{filename}")
            print(f"    â†’ Downloaded {filename}")

        elif action == 'extract':
            variable_name = step['variable']
            value = step.get('value')

            if value is None:
                selector = step['selector']
                try:
                    text = self.page.locator(selector).inner_text().strip()
                    # Try to convert to number if possible (basic heuristic)
                    import re
                    # Remove currency symbols and commas
                    clean_text = re.sub(r'[^\d.-]', '', text)
                    try:
                        value = float(clean_text) if '.' in clean_text else int(clean_text)
                    except ValueError:
                        value = text
                    print(f"    â†’ Extracted '{variable_name}' = {value} from {selector}")
                except Exception as e:
                    print(f"    âš ï¸  Failed to extract from {selector}: {e}")
                    return
            else:
                print(f"    â†’ Using provided value for '{variable_name}' = {value}")
            
            # Update memory
            self._save_memory(variable_name, value, 'extraction')
            
            # Update extracted data
            if not hasattr(self, '_extracted_data'):
                self._extracted_data = {}
            self._extracted_data[variable_name] = value

        else:
            print(f"    âš ï¸  Unknown action: {action}")

    def _handle_step_error(
        self,
        error: Exception,
        step: Dict[str, Any],
        task_spec: Dict[str, Any],
        step_index: int
    ) -> ErrorReport:
        """Handle step execution error"""

        error_type = type(error).__name__

        # Create error report
        error_report = ErrorReport(
            task_id=task_spec['task_id'],
            error_type=error_type,
            timestamp=datetime.utcnow().isoformat() + "Z",
            step_index=step_index,
            error_message=str(error),
            step=step,
            context={
                "url": self.page.url if self.page else None
            }
        )

        # Try to capture screenshot
        try:
            screenshot_path = f"errors/{task_spec['task_id']}/error_step_{step_index}.png"
            os.makedirs(os.path.dirname(screenshot_path), exist_ok=True)
            if self.page:
                print(f"    âŒ Error URL: {self.page.url}")
                self.page.screenshot(path=screenshot_path)
                error_report.context['screenshot'] = screenshot_path
        except:
            pass

        # Apply error recovery strategy
        recovery = task_spec.get('error_recovery', {})

        if 'timeout' in error_type.lower():
            strategy = recovery.get('on_timeout', 'capture_state_and_abort')
            if strategy == 'capture_state_and_abort':
                error_report.final_state = 'aborted'

        # Save error report
        error_report.save(f"errors/{task_spec['task_id']}")

        return error_report

    def _verify_success(self, task_spec: Dict[str, Any]) -> bool:
        """Verify task success criteria"""
        success_criteria = task_spec.get('success_criteria', [])

        if not success_criteria:
            return True

        # Refresh memory from DB to include runtime updates (e.g., new orders)
        self._load_memory()

        # Create DSL evaluator
        dsl = AssertionDSL(self.page, self.memory, self._env_api)

        for criterion in success_criteria:
            try:
                result = dsl.evaluate(criterion)
                if not result:
                    print(f"    âŒ Criterion failed: {criterion}")
                    return False
                else:
                    print(f"    âœ… Criterion passed: {criterion[:80]}...")
            except Exception as e:
                print(f"    âŒ Criterion error: {e}")
                return False

        return True

    def _update_memory(self, task_spec: Dict[str, Any]):
        """Update memory based on task execution"""
        memory_keys = task_spec.get('memory_keys', [])

        print(f"\nðŸ’¾ Updating {len(memory_keys)} memory entries...")

        # Load expected memory if available
        task_dir = Path(task_spec.get('_path', '.')).parent
        expected_memory_path = Path(task_dir) / 'expected_memory.json'

        if expected_memory_path.exists():
            with open(expected_memory_path) as f:
                expected_memory = json.load(f)

            for key, entry in expected_memory.items():
                value = entry.get('value')
                source = entry.get('source', task_spec['task_id'])
                confidence = entry.get('confidence', 1.0)

                self._save_memory(key, value, source, confidence)
                print(f"  âœ… {key} = {value}")

    def _save_result(self, result: ExecutionResult):
        """Save execution result to database"""
        if not os.path.exists(self.database_path):
            return

        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()

            cursor.execute("""
                INSERT INTO task_executions (
                    task_id, agent_version, state, started_at, completed_at,
                    error_type, error_message, steps_completed, steps_total
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                result.task_id,
                "executor-v1.0.0",
                result.final_state,
                datetime.utcnow().isoformat(),
                datetime.utcnow().isoformat(),
                result.error.error_type if result.error else None,
                result.error.error_message if result.error else None,
                result.steps_completed,
                result.steps_total
            ))

            conn.commit()
            conn.close()

            print(f"âœ… Execution result saved to database")

        except Exception as e:
            print(f"âš ï¸  Error saving result: {e}")


# Convenience function
def execute_task(task_spec_path: str, oracle_trace_path: Optional[str] = None, **kwargs) -> ExecutionResult:
    """
    Execute a task (convenience function)

    Args:
        task_spec_path: Path to task_spec.json
        oracle_trace_path: Optional path to oracle_trace.json
        **kwargs: Additional arguments for TaskExecutor

    Returns:
        ExecutionResult
    """
    executor = TaskExecutor(**kwargs)
    return executor.run(task_spec_path, oracle_trace_path)


if __name__ == "__main__":
    # Example usage
    import sys

    if len(sys.argv) < 2:
        print("Usage: python executor.py <task_spec.json> [oracle_trace.json]")
        sys.exit(1)

    task_spec = sys.argv[1]
    oracle_trace = sys.argv[2] if len(sys.argv) > 2 else None

    result = execute_task(task_spec, oracle_trace, headless=False, slow_mo=500)

    print("\n" + "="*80)
    print("FINAL RESULT")
    print("="*80)
    print(json.dumps(result.to_dict(), indent=2))
